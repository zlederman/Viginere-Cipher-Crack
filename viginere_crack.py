# -*- coding: utf-8 -*-
""".ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z1oR_YoCrihXhKWQSEPYDPFXrW612v03
"""

import re
import matplotlib.pyplot as plt
import pandas as pd
from collections import Counter
from itertools import permutations

def hex_to_bin(data):
  data = data.replace(' ','')
  data = re.findall('..',data)
  return ''.join([bin(int(a,16))[2::].zfill(8) for a in data])
                              
def get_data():
  with open('crack_me_hex.txt','r') as f:
    corpus = hex_to_bin(f.read())
    key_lengths = key_len(corpus)
    blocks = get_blocks(key_lengths, corpus)
    keys = []
    
    tran = transpose(blocks[0])
    for t in tran:
      keys.append(solve_singlet(t))
    print(''.join(keys))
  

def compare(x,y):
  val = x ^ y
  return bin(val).count("1")

def hamming_distance(s1, s2):
  # convert binary to int
  likeness = 0
  int1 = [int(s,2) for s in s1]
  int2 = [int(s,2) for s in s2]
  for i in range(len(int1)):
    likeness += compare(int1[i],int2[i])

  return likeness


def key_len(data):
  # try and determine the likeness of a key length using the hamming distance
  possible_keys = []
  for i in range(2,41):
     size = '........'*i
     blocks = re.findall(size, data)
     
     total = 0
     likeness = 0
     for n in range(len(blocks)-1):
       likeness += hamming_distance(blocks[n], blocks[n+1])/i
       total = n
    
     possible_keys.append((likeness/total, i))
  possible_keys.sort(key=lambda tup: tup[0]) 

  return [length for likeness,length in possible_keys[0:3]]

def get_blocks(keySizes, data):
  blocks =[]
  for size in keySizes:
    block_size = '........'*size
    block = re.findall(block_size, data)
    blocks.append(block)
  return blocks


def transpose(block):
  n = len(block[0])//8
  arr = ['']*n
  for i in range(n):
    for byte in block:
      byte = re.findall('........',byte)
      arr[i] += byte[i]

  return arr  

dic = {
   'a':11.682, 
   'b':4.434,
   'c':5.238,	
   'd':3.174,	
   'e':2.799,	
   'f':4.027,	
   'g':1.642,	
   'h':4.200,	
   'i':7.294,	
   'j':0.511,	
   'k':0.856,	
   'l':2.415,	
   'm':3.826,	
   'n':2.284,	
   'o':7.631,	
   'p':4.319,	
   'q':0.222,	
   'r':2.826,
   's':6.686,
   't':15.978,	
   'u':1.183,	
   'v':0.824,	
   'w':5.497,	
   'x':0.045,	
   'y':0.763,
   'z':0.045
}

def score_string(string):
  score = 0
  if string:
    string = string.lower()
    for c in string:
      if dic.get(c) != None:
        score += dic[c]
      else:
        score -= 5
    return score
  else:
    return 0


def solve_singlet(transposed):
  transposed = re.findall('........',transposed)
  transposed = [int(a,2) for a in transposed]
                
  arr = []
  for i in range(32,128):
    foo = ''.join([chr(a ^ i) for a in transposed])
    score = score_string(foo)
    arr.append((score, chr(i)))
  arr.sort(key=lambda tup: tup[0], reverse=True)
  max = arr[0]
  print(arr[0],arr[1],arr[2])
  return max[1]


get_data()

